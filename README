Assignment 1

Extension 1
1.1
      	param.h: 
	12) #define MAX_PATH_ENTRIES 	10 //max entries of paths to be allowed
      	
      	exec.c:
	10) char* pathVariable[MAX_PATH_ENTRIES]={0};
	11) static int place_to_add_path=0;
	17) char newPath[2*INPUT_BUF]={0};
	25) if((ip = namei(path)) == 0)
		  {
		    for( i=0;i<place_to_add_path;i++)
		    {
		      
		      if((ip = namei(newstrcat(newPath,pathVariable[i],path))) != 0){
		  	   break;
		      }
		    }
		    if(i>=place_to_add_path)
		    return -1;
		  }
1.2
      	defs.h:
	25)  int definition_add_path(char*);
	142) char* 	newstrcat(char*,char*,char*);

      	syscall.c:
	101) extern int sys_add_path(void);
	126) [SYS_add_path] sys_add_path

      	syscall.h:
	24) #define SYS_add_path  22

      	usys.S:
	32) SYSCALL(add_path)

		exec.c
	118) 
		int
		definition_add_path(char *path){
		  if(place_to_add_path>MAX_PATH_ENTRIES){
		      return -1;
		  }
		  safestrcpy(pathVariable[place_to_add_path],path,strlen(path)+1);
		  place_to_add_path++;
		  
		  return 0;
		}
  1.3
      user.h:
	 25) int add_path(char*);

      added file export.c
      added export.c in makefile (everywhere ls.c was)

Extension 2
	console.c:
	126)
		#define KEY_UP    0xE2
		#define KEY_DN    0xE3
		#define KEY_LF    0xE4
		#define KEY_RT    0xE5
	150)
		crt[pos] = ' ' | 0x0700;
	153)
	    if(c == KEY_LF){
		  if(pos > 0){
		    --pos;
		  }
		}  else
	170) commented out
	182)
		if(c == KEY_LF){
			uartputc('\b'); 
			} else
		193)
			#define MAX_HISTORY_LENGTH  20
		201)
			uint last;  // Edit index
		char history[INPUT_BUF][MAX_HISTORY_LENGTH];
		uint history_start;
		uint history_indx;
		uint history_end;
	210)
		int 
		replace_line_on_screen()
		{
		  int c;
		  uint counter;

		  while(input.e > input.w)
		    {
		      input.buf[input.e-- % INPUT_BUF] = 0;
		      input.last--;
		      consputc(BACKSPACE);
		    }
		    for(counter=0; c!=0 && c!='\n' && c!='\r' ;counter++)
		    {
		      c=input.history[input.history_indx % MAX_HISTORY_LENGTH ][counter];
		      input.buf[input.e++ % INPUT_BUF] = c;
		      input.last++;
		      consputc(c);
		    }
		    return 0;
		}
	248)
		input.last--;
	257)
		input.last--;
	262)
	    case KEY_LF:  // left arrow
	    if(input.e != input.w)
	    {
	      input.e--;
	      consputc(c);
	    }
	    break;

	  case KEY_RT:  // right arrow
	    if(input.e < input.last)
	    {
	      consputc(input.buf[input.e% INPUT_BUF]);
	      input.e++;
	    }
	    break;

	    case KEY_DN:  // down arrow
	  
	    if((input.history_end % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH) 
	      && ((input.history_indx + 1) % MAX_HISTORY_LENGTH) != (input.history_end % MAX_HISTORY_LENGTH ))
	    {
	      input.history_indx++;
	      replace_line_on_screen();
	    }
	    break;

	    case KEY_UP:  // up arrow
	   
	    if((input.history_end % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH)
	    && ((input.history_indx) % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH) )
	    {
	      input.history_indx--;
	      replace_line_on_screen();
	    }
	    break;
	302)
		input.last++;
	306)
	    strncpy(input.history[input.history_end % MAX_HISTORY_LENGTH]
	      ,&input.buf[input.w% INPUT_BUF]
	      ,input.last-input.w-1);
	    input.history_indx=++input.history_end;
	    if ((input.history_end % MAX_HISTORY_LENGTH) == (input.history_start % MAX_HISTORY_LENGTH))
	    {
	     input.history_start++;
	 	}
Task 2
	proc.h:
	74)
		//Time Related fields
		uint ctime;       //creation time
  		uint etime;       //end time
  		uint iotime;      //waiting for I/O time
  		uint rtime;       //running time
  		int  qanta
  	proc.c:
  	29)
  		//used to get the number of ticks since the clock started
		int
		get_time(){
		  uint rticks;

		  acquire(&tickslock);
		  rticks=ticks;
		  release(&tickslock);
		return rticks;
		}

		void
		pinit(void)
		{
		  initlock(&ptable.lock, "ptable");
		}
	47)
		void
			sleepingUpDate(void)
			{
			     struct proc *p;
			  acquire(&ptable.lock);
			     
			  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
			        
			            if(p->state == SLEEPING){
			              p->iotime++;
			              
			            }
			            if(p->state == RUNNING){
			              p->rtime++;
			              p->quanta--;
			              
			            }
			          
			        }
			 release(&ptable.lock);
			}

			void
			changeStatus(enum procstate s,struct proc* p)
			{
			  p->state=s;
			  if(s==RUNNABLE){}
			    //////////////////////// add to queue //////////////////
			    if(s==RUNNING)
			      p->quanta=QUANTA;
			}


	103)  changeStatus(EMBRYO,p);
		

	106)
		//update time of creation
  		p->ctime=get_time();
  		p->iotime=0;
  		p->rtime=0;


  	115)  changeStatus(UNUSED,p);
  	
  	165) changeStatus(RUNNABLE,p);	

  	205)  changeStatus(UNUSED,np);
  	221) changeStatus(RUNNABLE,np);
  	248)  proc->etime=get_time();
	265) changeStatus(ZOMBIE,proc);

	292) changeStatus(UNUSED,p);

	


    315)
    	int 
		wait2(int *wtime, int *rtime, int *iotime)
		{
		struct proc *p;
		  int havekids, pid;

		  acquire(&ptable.lock);
		  for(;;){
		    // Scan through table looking for zombie children.
		    havekids = 0;
		    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
		      if(p->parent != proc)
		        continue;
		      havekids = 1;
		      if(p->state == ZOMBIE){
		        // Found one.
		        pid = p->pid;
		        kfree(p->kstack);
		        p->kstack = 0;
		        freevm(p->pgdir);
		        changeStatus(UNUSED,p);
		        p->pid = 0;
		        p->parent = 0;
		        p->name[0] = 0;
		        p->killed = 0;
		        *wtime=p->etime-p->ctime-p->rtime-p->iotime;
		        *rtime=p->rtime;
		        *iotime=p->iotime;
		        
		        release(&ptable.lock);
		        return pid;
		      }
		    }

		    // No point waiting if we don't have any children.
		    if(!havekids || proc->killed){
		      release(&ptable.lock);
		      return -1;
		    }

		    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
		    sleep(proc, &ptable.lock);  //DOC: wait-sleep
		  }
		}
	 

	 409) changeStatus(RUNNING,p);	

	 449) changeStatus(RUNNABLE,proc);
	 498) changeStatus(SLEEPING,proc);

	589)
		cprintf("id:%d status:%s name:%s\n", p->pid, state, p->name);
   			 cprintf("ctime:%d rtime:%d iotime:%d etime:%d\n", p->ctime, p->rtime, p->iotime,p->etime);
      	  cprintf("quanta is:%d\n", p->quanta);


sysproc.c:

	106)
		int
			sys_wait2(void)
			{
			  int wtime;
			  int rtime;
			  int iotime;
			  if(argint(0, &wtime) < 0){
			      return -1;
			    }
			    if(argint(1, &rtime) < 0){
			      return -1;
			    }
			    if(argint(2, &iotime) < 0){
			      return -1;
			    }
			return wait2((int *)wtime,(int *)rtime,(int *)iotime);

			}
defs.h:
	
	120) 
			int 			wait2(int*, int*, int*);
			void			sleepingUpDate(); 


syscall.c:
	102) 
		extern int sys_wait2(void);
	127) 
		[SYS_wait2]    sys_wait2

syscall.h:
	25) 
		#define SYS_wait2  23

usys.S:
	33)
		SYSCALL(wait2)

user.h:
	26)	
		int wait2(int*, int*, int*);

trap.c:  56)  sleepingUpDate();
		 110)  
		 		if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER && proc->quanta<=0)
    				yield();
			
Task3 :
		trap.c line 24 arg2 was change from 1 to QUANTA