Assignment 1

Extension 1
1.1
      	param.h: 
	12) #define MAX_PATH_ENTRIES 	10 //max entries of paths to be allowed
      	
      	exec.c:
	10) char* pathVariable[MAX_PATH_ENTRIES]={0};
	11) static int place_to_add_path=0;
	17) char newPath[2*INPUT_BUF]={0};
	25) if((ip = namei(path)) == 0)
		  {
		    for( i=0;i<place_to_add_path;i++)
		    {
		      
		      if((ip = namei(newstrcat(newPath,pathVariable[i],path))) != 0){
		  	   break;
		      }
		    }
		    if(i>=place_to_add_path)
		    return -1;
		  }
1.2
      	defs.h:
	25)  int definition_add_path(char*);
	142) char* 	newstrcat(char*,char*,char*);

      	syscall.c:
	101) extern int sys_add_path(void);
	126) [SYS_add_path] sys_add_path

      	syscall.h:
	24) #define SYS_add_path  22

      	usys.S:
	32) SYSCALL(add_path)

		exec.c
	118) 
		int
		definition_add_path(char *path){
		  if(place_to_add_path>MAX_PATH_ENTRIES){
		      return -1;
		  }
		  safestrcpy(pathVariable[place_to_add_path],path,strlen(path)+1);
		  place_to_add_path++;
		  
		  return 0;
		}
  1.3
      user.h:
	 25) int add_path(char*);

      added file export.c
      added export.c in makefile (everywhere ls.c was)

Extension 2
	console.c:
	126)
		#define KEY_UP    0xE2
		#define KEY_DN    0xE3
		#define KEY_LF    0xE4
		#define KEY_RT    0xE5
	150)
		crt[pos] = ' ' | 0x0700;
	153)
	    if(c == KEY_LF){
		  if(pos > 0){
		    --pos;
		  }
		}  else
	170) commented out
	182)
		if(c == KEY_LF){
			uartputc('\b'); 
			} else
		193)
			#define MAX_HISTORY_LENGTH  20
		201)
			uint last;  // Edit index
		char history[INPUT_BUF][MAX_HISTORY_LENGTH];
		uint history_start;
		uint history_indx;
		uint history_end;
	210)
		int 
		replace_line_on_screen()
		{
		  int c;
		  uint counter;

		  while(input.e > input.w)
		    {
		      input.buf[input.e-- % INPUT_BUF] = 0;
		      input.last--;
		      consputc(BACKSPACE);
		    }
		    for(counter=0; c!=0 && c!='\n' && c!='\r' ;counter++)
		    {
		      c=input.history[input.history_indx % MAX_HISTORY_LENGTH ][counter];
		      input.buf[input.e++ % INPUT_BUF] = c;
		      input.last++;
		      consputc(c);
		    }
		    return 0;
		}
	248)
		input.last--;
	257)
		input.last--;
	262)
	    case KEY_LF:  // left arrow
	    if(input.e != input.w)
	    {
	      input.e--;
	      consputc(c);
	    }
	    break;

	  case KEY_RT:  // right arrow
	    if(input.e < input.last)
	    {
	      consputc(input.buf[input.e% INPUT_BUF]);
	      input.e++;
	    }
	    break;

	    case KEY_DN:  // down arrow
	  
	    if((input.history_end % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH) 
	      && ((input.history_indx + 1) % MAX_HISTORY_LENGTH) != (input.history_end % MAX_HISTORY_LENGTH ))
	    {
	      input.history_indx++;
	      replace_line_on_screen();
	    }
	    break;

	    case KEY_UP:  // up arrow
	   
	    if((input.history_end % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH)
	    && ((input.history_indx) % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH) )
	    {
	      input.history_indx--;
	      replace_line_on_screen();
	    }
	    break;
	302)
		input.last++;
	306)
	    strncpy(input.history[input.history_end % MAX_HISTORY_LENGTH]
	      ,&input.buf[input.w% INPUT_BUF]
	      ,input.last-input.w-1);
	    input.history_indx=++input.history_end;
	    if ((input.history_end % MAX_HISTORY_LENGTH) == (input.history_start % MAX_HISTORY_LENGTH))
	    {
	     input.history_start++;
	 	}
Task 2
	proc.h:
	72)
		//Time Related fields
		uint ctime;       //creation time
  		uint etime;       //end time
  		uint iotime;      //waiting for I/O time
  		uint rtime;       //running time
  	proc.c:
  	23)
  		//used to get the number of ticks since the clock started
		int
		get_time(){
		  uint rticks;

		  acquire(&tickslock);
		  rticks=ticks;
		  release(&tickslock);
		return rticks;
		}

		void
		pinit(void)
		{
		  initlock(&ptable.lock, "ptable");
		}
	62)
		//update time of creation
  		p->ctime=get_time();
  		p->etime=0;
  		p->iotime=0;
  		p->rtime=0;
	203)
		proc->rtime=get_time()-proc->changed_status_time;
  		proc->etime=get_time();

  	253) 
  	     p->ctime=0;
        p->rtime=0;
        p->etime=0;
        p->changed_status_time=0;
        p->iotime=0;	


    275)
    	int 
			wait2(int *wtime, int *rtime, int *iotime)
			{
			struct proc *p;
			  int havekids, pid;

			  acquire(&ptable.lock);
			  for(;;){
			    // Scan through table looking for zombie children.
			    havekids = 0;
			    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
			      if(p->parent != proc)
			        continue;
			      havekids = 1;
			      if(p->state == ZOMBIE){
			        // Found one.
			        pid = p->pid;
			        kfree(p->kstack);
			        p->kstack = 0;
			        freevm(p->pgdir);
			        p->state = UNUSED;
			        p->pid = 0;
			        p->parent = 0;
			        p->name[0] = 0;
			        p->killed = 0;
			        *wtime=p->etime-p->ctime-p->rtime-p->iotime;
			        *rtime=p->rtime;
			        *iotime=p->iotime;
			        p->ctime=0;
			        p->rtime=0;
			        p->etime=0;
			        p->changed_status_time=0;
			        p->iotime=0;
			        release(&ptable.lock);
			        return pid;
			      }
			    }

			    // No point waiting if we don't have any children.
			    if(!havekids || proc->killed){
			      release(&ptable.lock);
			      return -1;
			    }

			    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
			    sleep(proc, &ptable.lock);  //DOC: wait-sleep
			  }
			}
	 	   
	375)
		p->changed_status_time=get_time();
	377)
		proc->rtime += get_time()-proc->changed_status_time;
		 p->changed_status_time=get_time(); 
	415)
		proc->rtime += get_time()-proc->changed_status_time;
  		proc->changed_status_time = get_time();
  	467)
		proc->rtime += get_time()-proc->changed_status_time;
  		proc->changed_status_time = get_time();
  	493)
      	p->iotime += get_time()-p->changed_status_time;
      	p->changed_status_time=get_time();
    523)
      	p->iotime += get_time()-p->changed_status_time;
      	p->changed_status_time=get_time();
    
	563)
		cprintf("id:%d status:%s name:%s\n", p->pid, state, p->name);
	    cprintf("ctime:%d rtime:%d iotime:%d etime:%d\n", p->ctime, p->rtime, p->iotime,p->etime);
sysproc.c:

	106)
		int
			sys_wait2(void)
			{
			  int wtime;
			  int rtime;
			  int iotime;
			  if(argint(0, &wtime) < 0){
			      return -1;
			    }
			    if(argint(1, &rtime) < 0){
			      return -1;
			    }
			    if(argint(2, &iotime) < 0){
			      return -1;
			    }
			return wait2((int *)wtime,(int *)rtime,(int *)iotime);

			}
defs.h:
	
	120) 
			int 			wait2(int*, int*, int*);

syscall.c:
	102) 
		extern int sys_wait2(void);
	127) 
		[SYS_wait2]    sys_wait2

syscall.h:
	25) 
		#define SYS_wait2  23

usys.S:
	33)
		SYSCALL(wait2)

user.h:
	26)	
		int wait2(int*, int*, int*);
			
Task3 :
		trap.c line 24 arg2 was change from 1 to QUANTA