HW 2

Assignment 1:
1.1:

  signal.c:
	//all includes were already added before
	void 
	def_Handler()
	{
		cprintf("A signal was accepted by process %d\n",proc->pid);
	}
	
  proc.h:
  
    84) //signal supporting fields
	uint pending;
	sighandler_t handlers[NUMSIG]; //the handlers of the process
	uint alarm; // counter for SIGALARM
	
  proc.c:
    239)
        p->pending=0;
	p->alarm=-1; //not set

	for(i=0;i<NUMSIG;i++)
	{
	  p->handlers[i]=(sighandler_t)&def_Handler;
	}
1.2-1.3:
  
  defs.h:
    125)int 		handle_sigsend(int,int);
  
  usys.S:
    36) SYSCALL(signal)
	SYSCALL(sigsend)
	
  syscall.h:
    27) #define SYS_signal   26
	#define SYS_sigsend  27
	
  syscall.c:
    105)extern int sys_signal(void);
	extern int sys_sigsend(void);
    
    137)[SYS_signal] sys_signal,
	[SYS_sigsend] sys_sigsend,
	
  user.h:
    30)	int signal(int,sighandler_t);
	int sigsend(int,int);
	
  sysproc.c:
    137)
      int
      sys_signal(void)
      {
	int handler;
	int signum;
	
	if(argint(0, &signum) < 0){
	  cprintf("err1\n");
	  return -1;
	}
	if(argint(1, &handler) < 0){
	  cprintf("err2\n");
	  return -1;
	}
	if(signum < 0 || signum >= NUMSIG)
	{
	  cprintf("err3\n");
	  return -1;
	}
	cprintf("registering signal %d as handler %d\n",signum,handler);
	
	proc->handlers[signum-1]=(sighandler_t)handler;

	return 0;
      }

      int
      sys_sigsend(void)
      {
	int pid;
	int signum;

	if(argint(0, &pid) < 0){
	  cprintf("err1\n");
	  return -1;
	}
	if(argint(1, &signum) < 0){
	  cprintf("err2\n");
	  return -1;
	}
	if(signum < 0 || signum >= NUMSIG)
	{
	  cprintf("err1\n");
	  return -1;
	}
      pid = handle_sigsend(pid,signum);
	return pid;
      }
      
  proc.c:
    775)
      int
      handle_sigsend(int pid, int signum)
      {
	struct proc *p;

	acquire(&ptable.lock);
	    
	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
	{
	  if(p->pid == pid)
	  {
	    p->pending = p-> pending | (1 << (signum-1));

	    release(&ptable.lock);
	    return 0;
	  }
	}
	release(&ptable.lock);
	return -1;
      }
      
1.4:
  proc.c:
    528)
      int i=0;
      int bit=1;
      while(p->pending!=0)
      {
	if((p->pending & bit )>0)
	{
	  if(p->handlers[i] == &def_Handler)
	  {
	    def_Handler();
	  }
	  else
	  {
	    register_handler(p->handlers[i]);
	  }
	  p->pending = (p->pending) & ~bit ;
	  
	  break;
	}
	bit = bit *2;
	i++;
	if(i>=NUMSIG)
	{
	  bit=1;
	  i=0;
	}
      }
      
 1.5:
  proc.c:
    352)  for (i =0 ; i<NUMSIG ; i++)
	  {
	    np->handlers[i]=proc->handlers[i];
	  }
1.6:

  sysproc.c:
    186)
      int 
      sys_alarm(void)
      {
	int alarm_time;
	if(argint(0, &alarm_time) < 0){

	  return -1;
	}
	if (alarm_time<0)
	{
	  return -1;
	}
	if (alarm_time==0)
	{
	  proc->pending = proc-> pending & ~(1 << (SIGALRM-1));
	  return -1;
	}
	
	//proc->pending = proc-> pending | (1 << SIGALRM);
	proc->alarm = alarm_time;
	return 0;

      };

  usys.S:
    38) SYSCALL(alarm)
    
  syscall.h:
    29) #define SYS_alarm  28
  
  syscall.c:
    107) extern int sys_alarm(void);
    139) [SYS_alarm] sys_alarm
    
  user.h
    32) int alarm(int);
    
  proc.c
    89)
        if(p->alarm>=0)
	{
	  p->alarm--;
	  if(p->alarm==0)
	  {
	    p->pending = p-> pending | (1 << (SIGALRM-1));
	    p->alarm=-1; 
	  }

	}