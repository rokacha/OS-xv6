Assignment 1

Extension 1
1.1
      	param.h: 
	12) #define MAX_PATH_ENTRIES 	10 //max entries of paths to be allowed
      	
      	exec.c:
	10) char* pathVariable[MAX_PATH_ENTRIES]={0};
	11) static int place_to_add_path=0;
	17) char newPath[2*INPUT_BUF]={0};
	25) if((ip = namei(path)) == 0)
		  {
		    for( i=0;i<place_to_add_path;i++)
		    {
		      
		      if((ip = namei(newstrcat(newPath,pathVariable[i],path))) != 0){
		  	   break;
		      }
		    }
		    if(i>=place_to_add_path)
		    return -1;
		  }
1.2
      	defs.h:
	25)  int definition_add_path(char*);
	141) char* 	newstrcat(char*,char*,char*);

      	syscall.c:
	101) extern int sys_add_path(void);
	125) [SYS_add_path] sys_add_path

      	syscall.h:
	24) #define SYS_add_path  22

      	usys.S:
	32) SYSCALL(add_path)

		exec.c
	118) 
		int
		definition_add_path(char *path){
		  if(place_to_add_path>MAX_PATH_ENTRIES){
		      return -1;
		  }
		  safestrcpy(pathVariable[place_to_add_path],path,strlen(path)+1);
		  place_to_add_path++;
		  
		  return 0;
		}
  1.3
      user.h:
	 25) int add_path(char*);

      added file export.c
      added export.c in makefile (everywhere ls.c was)

Extension 2
	console.c:
	126)
		#define KEY_UP    0xE2
		#define KEY_DN    0xE3
		#define KEY_LF    0xE4
		#define KEY_RT    0xE5
	150)
		crt[pos] = ' ' | 0x0700;
	153)
	    if(c == KEY_LF){
		  if(pos > 0){
		    --pos;
		  }
		}  else
	170) commented out
	182)
		if(c == KEY_LF){
			uartputc('\b'); 
			} else
		193)
			#define MAX_HISTORY_LENGTH  20
		201)
			uint last;  // Edit index
		char history[INPUT_BUF][MAX_HISTORY_LENGTH];
		uint history_start;
		uint history_indx;
		uint history_end;
	210)
		int 
		replace_line_on_screen()
		{
		  int c;
		  uint counter;

		  while(input.e > input.w)
		    {
		      input.buf[input.e-- % INPUT_BUF] = 0;
		      input.last--;
		      consputc(BACKSPACE);
		    }
		    for(counter=0; c!=0 && c!='\n' && c!='\r' ;counter++)
		    {
		      c=input.history[input.history_indx % MAX_HISTORY_LENGTH ][counter];
		      input.buf[input.e++ % INPUT_BUF] = c;
		      input.last++;
		      consputc(c);
		    }
		    return 0;
		}
	248)
		input.last--;
	257)
		input.last--;
	262)
	    case KEY_LF:  // left arrow
	    if(input.e != input.w)
	    {
	      input.e--;
	      consputc(c);
	    }
	    break;

	  case KEY_RT:  // right arrow
	    if(input.e < input.last)
	    {
	      consputc(input.buf[input.e% INPUT_BUF]);
	      input.e++;
	    }
	    break;

	    case KEY_DN:  // down arrow
	  
	    if((input.history_end % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH) 
	      && ((input.history_indx + 1) % MAX_HISTORY_LENGTH) != (input.history_end % MAX_HISTORY_LENGTH ))
	    {
	      input.history_indx++;
	      replace_line_on_screen();
	    }
	    break;

	    case KEY_UP:  // up arrow
	   
	    if((input.history_end % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH)
	    && ((input.history_indx) % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH) )
	    {
	      input.history_indx--;
	      replace_line_on_screen();
	    }
	    break;
	302)
		input.last++;
	306)
	    strncpy(input.history[input.history_end % MAX_HISTORY_LENGTH]
	      ,&input.buf[input.w% INPUT_BUF]
	      ,input.last-input.w-1);
	    input.history_indx=++input.history_end;
	    if ((input.history_end % MAX_HISTORY_LENGTH) == (input.history_start % MAX_HISTORY_LENGTH))
	    {
	     input.history_start++;
	 	}
Task 2
	proc.h:
	18)
		//Time Related fields
		uint ctime;       //creation time
  		uint etime;       //end time
  		uint iotime;      //waiting for I/O time
  		uint rtime;       //running time
