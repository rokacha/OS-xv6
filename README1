Assignment 1

Extension 1
1.1
      	param.h: 
	12) #define MAX_PATH_ENTRIES 	10 //max entries of paths to be allowed
      	
      	exec.c:
	10) char* pathVariable[MAX_PATH_ENTRIES]={0};
	11) static int place_to_add_path=0;
	17) char newPath[2*INPUT_BUF]={0};
	25) if((ip = namei(path)) == 0)
		  {
		    for( i=0;i<place_to_add_path;i++)
		    {
		      
		      if((ip = namei(newstrcat(newPath,pathVariable[i],path))) != 0){
		  	   break;
		      }
		    }
		    if(i>=place_to_add_path)
		    return -1;
		  }
1.2
      	defs.h:
	25)  int definition_add_path(char*);
	142) char* 	newstrcat(char*,char*,char*);

      	syscall.c:
	101) extern int sys_add_path(void);
	126) [SYS_add_path] sys_add_path

      	syscall.h:
	24) #define SYS_add_path  22

      	usys.S:
	32) SYSCALL(add_path)

		exec.c
	118) 
		int
		definition_add_path(char *path){
		  if(place_to_add_path>MAX_PATH_ENTRIES){
		      return -1;
		  }
		  safestrcpy(pathVariable[place_to_add_path],path,strlen(path)+1);
		  place_to_add_path++;
		  
		  return 0;
		}
  1.3
      user.h:
	 25) int add_path(char*);

      added file export.c
      added export.c in makefile (everywhere ls.c was)

Extension 2
	console.c:
	126)
		#define KEY_UP    0xE2
		#define KEY_DN    0xE3
		#define KEY_LF    0xE4
		#define KEY_RT    0xE5
	150)
		crt[pos] = ' ' | 0x0700;
	153)
	    if(c == KEY_LF){
		  if(pos > 0){
		    --pos;
		  }
		}  else
	170) commented out
	182)
		if(c == KEY_LF){
			uartputc('\b'); 
			} else
		193)
			#define MAX_HISTORY_LENGTH  20
		201)
			uint last;  // Edit index
		char history[INPUT_BUF][MAX_HISTORY_LENGTH];
		uint history_start;
		uint history_indx;
		uint history_end;
	210)
		int 
		replace_line_on_screen()
		{
		  int c;
		  uint counter;

		  while(input.e > input.w)
		    {
		      input.buf[input.e-- % INPUT_BUF] = 0;
		      input.last--;
		      consputc(BACKSPACE);
		    }
		    for(counter=0; c!=0 && c!='\n' && c!='\r' ;counter++)
		    {
		      c=input.history[input.history_indx % MAX_HISTORY_LENGTH ][counter];
		      input.buf[input.e++ % INPUT_BUF] = c;
		      input.last++;
		      consputc(c);
		    }
		    return 0;
		}
	248)
		input.last--;
	256)
		 if(input.e<input.last){
          for (i =input.e;  i <= input.last;i++)
          {
            input.buf[(i-1)%INPUT_BUF]=input.buf[i%INPUT_BUF];
          }
          for (i = input.e; i < input.last; ++i)
          {
            consputc(KEY_RT);
          }
          for (i = input.e; i <= input.last; ++i)
          {
            consputc(BACKSPACE);
          }
          input.e--;
          input.last--;
          for (i = input.e; i < input.last; ++i)
          {
            consputc(input.buf[i%INPUT_BUF]);
          }
          for (i = input.e; i < input.last; ++i)
          {
            consputc(KEY_LF);
          }

        }
        else{
          input.e--;
          input.last--;
          consputc(BACKSPACE);
        }
	289)
	    case KEY_LF:  // left arrow
	    if(input.e != input.w)
	    {
	      input.e--;
	      consputc(c);
	    }
	    break;

	  case KEY_RT:  // right arrow
	    if(input.e < input.last)
	    {
	      consputc(input.buf[input.e% INPUT_BUF]);
	      input.e++;
	    }
	    break;

	    case KEY_DN:  // down arrow
	  
	    if((input.history_end % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH) 
	      && ((input.history_indx + 1) % MAX_HISTORY_LENGTH) != (input.history_end % MAX_HISTORY_LENGTH ))
	    {
	      input.history_indx++;
	      replace_line_on_screen();
	    }
	    break;

	    case KEY_UP:  // up arrow
	   
	    if((input.history_end % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH)
	    && ((input.history_indx) % MAX_HISTORY_LENGTH) != (input.history_start % MAX_HISTORY_LENGTH) )
	    {
	      input.history_indx--;
	      replace_line_on_screen();
	    }
	    break;
	329)
		if(input.e<input.last && c!='\n')
        {
          for (i = input.last; i >= input.e; i--)
          {
            input.buf[(i + 1)% INPUT_BUF]=input.buf[i% INPUT_BUF];
          }
          input.buf[input.e % INPUT_BUF] = c;
          input.last++;
          input.e++;
          for (i =input.e-1 ; i <input.last ; i++)
          {
            consputc(input.buf[i%INPUT_BUF]);
          }
          for(i=0;i<(input.last-input.e);i++)
          {
            consputc(KEY_LF);
          }
        }
        else
        {
          if(c=='\n'){
            input.e=input.last;
          }
          input.buf[input.e++ % INPUT_BUF] = c;
          input.last++;
          consputc(c);
        }
	358)
	    strncpy(input.history[input.history_end % MAX_HISTORY_LENGTH]
	      ,&input.buf[input.w% INPUT_BUF]
	      ,input.last-input.w-1);
	    input.history_indx=++input.history_end;
	    if ((input.history_end % MAX_HISTORY_LENGTH) == (input.history_start % MAX_HISTORY_LENGTH))
	    {
	     input.history_start++;
	 	}
Task 2
	proc.h:
		74)
			//Time Related fields
			uint ctime;       //creation time
	  		uint etime;       //end time
	  		uint iotime;      //waiting for I/O time
	  		uint rtime;       //running time
	  		int  qanta
  	proc.c:
	  	29)
	  		//used to get the number of ticks since the clock started
			int
			get_time(){
			  uint rticks;

			  acquire(&tickslock);
			  rticks=ticks;
			  release(&tickslock);
			return rticks;
			}

			void
			pinit(void)
			{
			  initlock(&ptable.lock, "ptable");
			}
		47)
			void
				sleepingUpDate(void)
				{
				     struct proc *p;
				  acquire(&ptable.lock);
				     
				  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
				        
				            if(p->state == SLEEPING){
				              p->iotime++;
				              
				            }
				            if(p->state == RUNNING){
				              p->rtime++;
				              p->quanta--;
				              
				            }
				          
				        }
				 release(&ptable.lock);
				}

				void
				changeStatus(enum procstate s,struct proc* p)
				{
				  p->state=s;
				  if(s==RUNNABLE){}
				    
				    if(s==RUNNING)
				      p->quanta=QUANTA;
				}


		103)  changeStatus(EMBRYO,p);
			

		106)
			//update time of creation
	  		p->ctime=get_time();
	  		p->iotime=0;
	  		p->rtime=0;


	  	115)  changeStatus(UNUSED,p);
	  	
	  	165) changeStatus(RUNNABLE,p);	

	  	205)  changeStatus(UNUSED,np);
	  	221) changeStatus(RUNNABLE,np);
	  	248)  proc->etime=get_time();
		265) changeStatus(ZOMBIE,proc);

		292) changeStatus(UNUSED,p);

	    315)
	    	int 
			wait2(int *wtime, int *rtime, int *iotime)
			{
			struct proc *p;
			  int havekids, pid;

			  acquire(&ptable.lock);
			  for(;;){
			    // Scan through table looking for zombie children.
			    havekids = 0;
			    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
			      if(p->parent != proc)
			        continue;
			      havekids = 1;
			      if(p->state == ZOMBIE){
			        // Found one.
			        pid = p->pid;
			        kfree(p->kstack);
			        p->kstack = 0;
			        freevm(p->pgdir);
			        changeStatus(UNUSED,p);
			        p->pid = 0;
			        p->parent = 0;
			        p->name[0] = 0;
			        p->killed = 0;
			        *wtime=p->etime-p->ctime-p->rtime-p->iotime;
			        *rtime=p->rtime;
			        *iotime=p->iotime;
			        
			        release(&ptable.lock);
			        return pid;
			      }
			    }

			    // No point waiting if we don't have any children.
			    if(!havekids || proc->killed){
			      release(&ptable.lock);
			      return -1;
			    }

			    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
			    sleep(proc, &ptable.lock);  //DOC: wait-sleep
			  }
			}
		 

		 409) changeStatus(RUNNING,p);	

		 449) changeStatus(RUNNABLE,proc);
		 498) changeStatus(SLEEPING,proc);

		589)
			cprintf("id:%d status:%s name:%s\n", p->pid, state, p->name);
	   			 cprintf("ctime:%d rtime:%d iotime:%d etime:%d\n", p->ctime, p->rtime, p->iotime,p->etime);
	      	  cprintf("quanta is:%d\n", p->quanta);


	sysproc.c:

		106)
			int
				sys_wait2(void)
				{
				  int wtime;
				  int rtime;
				  int iotime;
				  if(argint(0, &wtime) < 0){
				      return -1;
				    }
				    if(argint(1, &rtime) < 0){
				      return -1;
				    }
				    if(argint(2, &iotime) < 0){
				      return -1;
				    }
				return wait2((int *)wtime,(int *)rtime,(int *)iotime);

				}
	defs.h:
		
		120) 
				int 			wait2(int*, int*, int*);
				void			sleepingUpDate(); 


	syscall.c:
		102) 
			extern int sys_wait2(void);
		127) 
			[SYS_wait2]    sys_wait2

	syscall.h:
		25) 
			#define SYS_wait2  23

	usys.S:
		33)
			SYSCALL(wait2)

	user.h:
		26)	
			int wait2(int*, int*, int*);

	trap.c:  56)  sleepingUpDate();
		 110)  
		 		if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER && proc->quanta==0)
    				yield();
			
Task3 :
	Makefile:
		54)
			#adding the flag for scheduling policy
			ifndef SCHEDFLAG
				SCHEDFLAG = DEFAULT
			endif
		84)
			CFLAGS += -D SCHEDFLAG=SCHED_$(SCHEDFLAG)

	param.h:
		16)
			#define NUMBER_OF_QUEUES    	3//the number of queues
			#define NORMAL_PRIORITY_QUEUE	1//the middle queue's number
			#define SCHED_DEFAULT  			1// default scheduling policy
			#define SCHED_FRR				2//FIFO round robin scheduling policy
			#define SCHED_FCFS				3//FIFO round robin infinte time QUANTA
			#define SCHED_3Q				4//three priority queues scheduling policy
	proc.c:
		22) struct{
				struct spinlock lock;
				int list[NUMBER_OF_QUEUES*NPROC];
				int start[NUMBER_OF_QUEUES];
				int end[NUMBER_OF_QUEUES];  
			} queues;
		64)
			initlock(&queues.lock, "queue");
		  	for(i=0;i<NUMBER_OF_QUEUES*NPROC;i++)
			    queues.list[i]=-1;
		    for(i=0;i<NUMBER_OF_QUEUES;i++){
		  		queues.start[i]=0;
		  		queues.end[i]=0;
		  	}
		92)
			int
			findIndxOfProc(struct proc* np){
			  int i;
			  for(i=0; i < NPROC; i++)
			  {
			    if((&ptable.proc[i])->pid == np->pid){
			      return i;   
			    }
			  }
			 return -1;
			}

			int
			queuesAboveEmpty(int queue){
			  int ans = 1;
			  int placer;
			  if(queue==NUMBER_OF_QUEUES-1)
			    return 1;
			  
			  for(placer = (queue+1)*NPROC;placer<NUMBER_OF_QUEUES*NPROC;placer++)
			  {
			    ans = ans * (queues.list[placer]==-1)? 1 : 0;
			  }

			  return ans;
			}

			void
			changeStatus(enum procstate s,struct proc* p)
			{
			  
			  int location = findIndxOfProc(p);
			  
			 enum procstate prevState = p->state; 

			  p->state=s;

			  if(location<0)
			    cprintf("Cant find any processes with pid %d\n",p->pid);
			  
			    switch(SCHEDFLAG){

			      case SCHED_3Q:
			        if(s==RUNNABLE)
			        {
			          if(p->quanta==0)  //process was forced to yield last run
			          {
			            p->queue = (p->queue==0)? 0 : (p->queue-1);
			          }
			          if(prevState==SLEEPING)
			          {
			           p->queue= (p->queue==(NUMBER_OF_QUEUES-1))? (NUMBER_OF_QUEUES-1) : (p->queue+1); 
			          }
			          queues.list[queues.end[p->queue]%NPROC+(p->queue)*NPROC]=location;
			          p->placeInQueue=queues.end[p->queue]%NPROC;
			          queues.end[p->queue]++;
			        }
			        if(s==UNUSED || s==ZOMBIE || s==SLEEPING || s==RUNNING){
			          queues.list[ p->placeInQueue+NPROC * (p->queue)]=-1;
			          p->placeInQueue=-1;
			          if(ptable.proc[queues.list[queues.start[p->queue]]].pid == p->pid)
			          {
			            queues.start[p->queue]++;
			          }
			          if(s==RUNNING)
			          {
			            p->quanta=(p->queue==0)? -1 : QUANTA; //lowest queue works without preempting
			          }
			        }
			      break;

			      case SCHED_FCFS:
			      case SCHED_FRR:
			        if(s==RUNNABLE)
			        {
			          queues.list[queues.end[p->queue]%NPROC+(p->queue)*NPROC]=location;
			          p->placeInQueue=queues.end[p->queue]%NPROC;
			          queues.end[p->queue]++;
			        }
			        if(s==UNUSED || s==ZOMBIE || s==SLEEPING || s==RUNNING)
			        {
			          queues.list[ p->placeInQueue+NPROC * (p->queue)]=-1;
			          p->placeInQueue=-1;
			          if(ptable.proc[queues.list[queues.start[ p->queue ]]].pid==p->pid)
			          {
			            queues.start[p->queue]++;
			          }
			          if(s==RUNNING)
			          {
			            p->quanta=(SCHEDFLAG==SCHED_FRR)? QUANTA : -1;
			          } 
			        }
			      break;

			      default:
			        if(s==RUNNING){
			          p->quanta=QUANTA;
			        }
			      break;
			    }
			}
		215)
			p->queue=NORMAL_PRIORITY_QUEUE;

		518)void
			scheduler(void)
			{
			  struct proc *p;
			  int current;
			  int workingQueue;
			  for(;;){
			    // Enable interrupts on this processor.
			    sti();

			    // Loop over process table looking for process to run.
			    acquire(&ptable.lock);
			    switch(SCHEDFLAG){
			      case SCHED_3Q:
			        for(workingQueue=NUMBER_OF_QUEUES-1; workingQueue>=0 ; workingQueue--){
			          if(queuesAboveEmpty(workingQueue)){
			            for(current=queues.start[workingQueue];
			              current< queues.end[workingQueue];
			              current++)
			            {

			              if((queues.list[workingQueue*NPROC+current%NPROC]>=0) 
			                && queuesAboveEmpty(workingQueue))
			              {
			                proc = &ptable.proc[queues.list[workingQueue*NPROC+current%NPROC]];
			                operateProcess(proc);
			              }
			            }
			          }
			        }
			      break;

			      case SCHED_FCFS:
			      case SCHED_FRR:
			        for(current=queues.start[NORMAL_PRIORITY_QUEUE];
			          current<= queues.end[NORMAL_PRIORITY_QUEUE];
			          current++)
			        {
			          if(queues.list[NORMAL_PRIORITY_QUEUE*NPROC+current%NPROC]>=0){
			            proc = &ptable.proc[queues.list[NORMAL_PRIORITY_QUEUE*NPROC+current%NPROC]];
			            operateProcess(proc);
			          }
			        }
			      break;
			        
			      default:
			        for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
			          if(p->state != RUNNABLE)
			            continue;
			        
			          // Switch to chosen process.  It is the process's job
			          // to release ptable.lock and then reacquire it
			          // before jumping back to us.
			          proc = p;
			          operateProcess(proc);
			        }
			      break;
			    }
			        release(&ptable.lock);
			  }
			  
			}
		